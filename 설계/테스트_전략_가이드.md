# JWT 로그인 테스트 전략 가이드

## 1. 핵심 개념: "메서드를 호출하지 말고, 요청을 보내라"
Security 관련 코드(`Filter`)는 메서드를 직접 호출(`filter.attemptAuthentication(...)`)해서 테스트하기가 매우 까다롭습니다. 
`HttpServletRequest` 같은 복잡한 객체를 직접 만들어야 하기 때문입니다.
대신 **`MockMvc`** 라는 도구를 사용해서 **"마치 브라우저나 앱이 요청을 보낸 것처럼"** 가짜 요청을 서버에 쏘고, 
돌아오는 응답을 검사하는 **통합 테스트** 방식을 주로 사용합니다.
---
## 2. 테스트 대상 및 시나리오
### A. 일반 로그인 (`JwtLoginFilter`) -> 통합 테스트 추천
서버를 띄우고 실제 `/api/login` 경로로 요청을 보내서 필터가 잘 동작하는지 확인합니다.
1.  **앱 로그인 테스트 (JSON 응답 검증)**
    *   **행동:** `POST /api/login` 요청 전송 (Body: `{"username": "test", "password": "123"}`)
    *   **검증:** 응답 본문(Body)에 `access_token`이 JSON으로 들어있는지 확인.
2.  **웹 로그인 테스트 (Cookie 응답 검증)**
    *   **행동:** 위와 똑같이 보내되, 헤더에 `Accept: text/html`을 추가함.
    *   **검증:** 응답 헤더에 `Set-Cookie`가 존재하는지 확인.
3.  **실패 테스트**
    *   **행동:** 틀린 비밀번호로 요청.
    *   **검증:** 401 상태 코드와 에러 JSON 확인.

### B. OAuth2 로그인 (`OAuth2LoginSuccessHandler`) -> 단위 테스트 추천
OAuth2는 카카오/구글 서버랑 통신하는 과정을 테스트하기 힘듭니다.
그래서 **"로그인은 이미 성공했다고 치고(Mocking), 그 다음 처리를 잘 하는가?"** 에 집중해서 **단위 테스트**를 하는 게 효율적입니다.
1.  **앱 분기 테스트**
    *   **상황:** `InMemoryAuthorizationRequestRepository`에 `target=app`이 저장되어 있다고 가정.
    *   **행동:** 핸들러의 `onAuthenticationSuccess` 메서드 실행.
    *   **검증:** 리다이렉트 URL이 `http://10.0.2.2:8080...` 인지 확인.
2.  **웹 분기 테스트**
    *   **상황:** `target=web`이라고 가정.
    *   **행동:** 핸들러 실행.
    *   **검증:** 리다이렉트 URL이 `/map`이고, 쿠키가 생성되었는지 확인.

---

## 3. 요약
*   **일반 로그인:** `MockMvc`로 실제 요청 쏘기 (통합 테스트)
*   **OAuth2:** `SuccessHandler` 클래스만 따로 떼어서 로직 검사 (단위 테스트)

