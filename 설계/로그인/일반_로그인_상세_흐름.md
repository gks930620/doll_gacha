# 현재 프로젝트 일반 로그인 상세 흐름 (Code Level Analysis)

## 1. 로그인 시도 (요청 단계)
**파일:** `JwtLoginFilter.java`
**메서드:** `attemptAuthentication`
**URL:** `/api/login` (POST)

1.  **요청 가로채기:**
    *   Spring Security 설정(`SecurityConfig`)에 의해 `/api/login` 요청이 들어오면 `JwtLoginFilter`가 동작합니다.
    *   `UsernamePasswordAuthenticationFilter`를 상속받아 구현되었습니다.
2.  **JSON 파싱:**
    *   기본 필터는 `form-data`를 처리하지만, 우리는 REST API 방식이므로 `request.getInputStream()`을 통해 JSON Body를 읽습니다.
    *   `ObjectMapper`를 사용하여 `username`과 `password`를 추출합니다.
3.  **인증 토큰 생성:**
    *   추출한 정보로 `UsernamePasswordAuthenticationToken`(미인증 상태)을 생성합니다.
4.  **인증 위임:**
    *   `authenticationManager.authenticate(authRequest)`를 호출하여 검증을 시작합니다.

---

## 2. 인증 진행 (검증 단계)
**관여 파일:** `SecurityConfig`, `CustomUserDetailsService`, `CustomUserAccount`

1.  **AuthenticationManager:**
    *   등록된 `AuthenticationProvider`들을 순회하며 인증을 시도합니다.
    *   여기서는 `DaoAuthenticationProvider`가 동작합니다.
2.  **UserDetailsService 호출:**
    *   `CustomUserDetailsService.loadUserByUsername(username)`이 호출됩니다.
    *   DB에서 해당 유저 정보를 조회하고, `CustomUserAccount`(UserDetails 구현체)를 반환합니다.
3.  **비밀번호 검증:**
    *   `PasswordEncoder`(BCrypt)를 사용하여 입력받은 비밀번호와 DB의 암호화된 비밀번호를 비교합니다.
4.  **결과 반환:**
    *   일치하면 인증된 `Authentication` 객체를 반환하고, 불일치하면 `AuthenticationException`을 던집니다.

---

## 3. 로그인 성공 (응답 단계)
**파일:** `JwtLoginFilter.java`
**메서드:** `successfulAuthentication`

1.  **토큰 생성:**
    *   인증된 객체(`authResult`)에서 `username`을 꺼냅니다.
    *   `JwtUtil.createAccessToken(username)`: Access Token 생성 (짧은 만료 시간).
    *   `JwtUtil.createRefreshToken(username)`: Refresh Token 생성 (긴 만료 시간).
2.  **Refresh Token 저장:**
    *   `RefreshService.saveRefresh(refreshToken)`을 호출하여 DB에 저장합니다.
3.  **응답 분기 처리 (클라이언트 구분):**
    *   요청 헤더의 `Accept` 값을 확인합니다.
    *   **Case A (Web - Browser):** `Accept`에 `text/html`이 포함된 경우.
        *   `addCookie` 메서드로 Access/Refresh Token을 **HttpOnly 쿠키**에 담습니다.
        *   `maxAge`를 -1로 설정하여 브라우저 종료 시 삭제되도록 합니다 (Session Cookie).
        *   응답 상태 코드 200(OK)을 반환합니다.
    *   **Case B (App - Mobile/Postman):** 그 외의 경우.
        *   JSON Body에 토큰을 담아 응답합니다.
        *   `{ "access_token": "...", "refresh_token": "..." }`

---

## 4. 로그인 실패 (예외 처리)
**파일:** `JwtLoginFilter.java`
**메서드:** `unsuccessfulAuthentication`

1.  **실패 감지:** 인증 과정에서 예외가 발생하면 이 메서드가 호출됩니다.
2.  **원인 기록:**
    *   `request.setAttribute("ERROR_CAUSE", "로그인실패")`를 설정합니다.
3.  **위임:**
    *   `super.unsuccessfulAuthentication`을 호출하여 `AuthenticationEntryPoint`로 처리를 넘깁니다.
4.  **최종 응답 (SecurityConfig):**
    *   `authenticationEntryPoint`에서 JSON 에러 메시지를 생성하여 반환합니다.
    *   `{ "error": "아이디 또는 비밀번호가 일치하지 않습니다.", "cause": "로그인실패" }`

---

## 5. 이후 요청 처리 (JWT 검증)
**파일:** `JwtAccessTokenCheckAndSaveUserInfoFilter.java`
**동작:** 모든 요청마다 실행 (`OncePerRequestFilter`)

1.  **토큰 추출:**
    *   헤더(`Authorization: Bearer ...`) 또는 쿠키(`access_token`)에서 토큰을 찾습니다.
2.  **유효성 검사:**
    *   `JwtUtil.validateToken(token)`으로 위변조 및 만료 여부를 확인합니다.
    *   만료 시 `ERROR_CAUSE = "토큰만료"` 설정 후 필터 진행 (결국 401 에러).
3.  **인증 정보 설정:**
    *   유효하다면 `username`을 추출하여 `UserDetails`를 로드합니다.
    *   `SecurityContextHolder`에 `Authentication` 객체를 저장합니다.
    *   이제 컨트롤러에서 `@AuthenticationPrincipal` 등을 통해 유저 정보를 사용할 수 있습니다.

