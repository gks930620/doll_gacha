애초에 카카오나 네이버에 등록 안된 장소는 리뷰 쓸 가치도 없는 가게라고 생각하자!!!
있는  데이터들(가게들)만 가지고 무언가하기 + 없는 데이터들은 나중에 사용자 많아지면 추가하는 걸로
단 카카오 API 잘해서 왠만한건 다 잘나오게 해야됨.
인형뽑기( https://dollcatch.store/  
여기에 나무위키처럼 사용자가  몇일에 어떤인형봤는지..   또는 기계 힘 좋은지, 커뮤니티,  사진 등등 )
실제  방문기록해서 있는거 확인된 가게   랑    카카오맵에서 대충 검색한 가게  비교하는 기능
==> 실제로 있는것만 제공해줘야함
서버 여러대라면 jwt or websocket  시 결국 redis를 쓰긴 써야하는데..



- 기본 API LayerArchitecture
Controller  -> Service -> Repository
Controller에서 repository 사용 금지, Entity 사용금지
Service에서 entity dto 변환 
1API  = 1Controller = 1Service메소드  
(service의 메소드A,B가 비슷하다면  A,B만들고 공통인 private메소드 한개로 묶기)
select만 하는 경우 queryDSL에서 직접 DTO 리턴이 오히려 권장..

- 파일 
파일업로드는 한곳에서 관리
프론트쪽에서 게시판 API  + 파일 API 따로 요청 
트랜잭션 관리 안되서 파일만 따로 업로드 되는 경우가 있겠지만 배치로 해결하는 방식.
File을  공통으로 관리하면 게시판별, 용도별 구분을 하는 방법이 여러개있음. (상속,중간매핑, Enum )


- JPA 
양방향 지양 :  글 하나에서 여러개 리뷰 보여주기
==> 프론트에서 글 API 요청 따로, 리뷰 API 요청 따로
글 1개에 대한 자식들 일 땐 API 분리
트랜잭션 문제로 insert update 에서 같이등록한다고도 한다는데...
부모글만 삭제되는 문제는 나중에 배치로 해결하는게 요즘 추세
LIst처럼 데이터 여러개일 때 연관관계를 가져온다면 왠만하면 서버단에서 다 세팅
( 이거를 처리하는게 10개의 부모글  +  10개 부모글의 ID얻기 ==> Inquery
repository에서 한번에 하는게 좋은듯.)
이후 성능 등의 문제가 있다면 개선 

DTO ENTITY : Entity에는 최대한 메소드가 없게... 변환메소드 다 dto에 넣기
DTO dto= DTO.from(entity);
Entity entity= dto.toEntity();
DTO는 기본적으로 공통쓰다가 새로운게 필요하다고 판단되면 그때그때 바로바로 만들기
DB에 데이터 변경을 위한 entity의 편의 메소드는 있어도 좋음
굳이 다 service단에서 할 필요는 없음.
엔티티의 편의메소드에도  exception 있어도 되지. 그게 오히려 객체지향적인설계 

댓글목록에서 유저이름이 필요 ==>@EntityGraph나 jpql인데.. 난 jpql 선호
부모글이 삭제됐을 때  자식들 다 삭제하기 vs 부모글 없는 데이터 나중에 배치로..
연관관계를 맺어서 데이터가 필요하다면 findByEntity가 맞지만 단순 조회하렴findBy부모EntityId.
Pageable은controller의 파라미터에 직접.  (0,1은 클라이언트가 처리한다. )


 - 응답 
프론트엔드에서 쉽게 처리하기 위한 APIReponse 적용하기  ==> ResponseEntity<APIResponse<T>>
Page<>는 너무  많음..  실제 클라이언트가 사용할만한 데이터로 바꿔서 해야될 듯
에러응답은  에러 응답 규격 정하기 (ErrorResponseDTO)
모든 에러 상황에서 일관된 JSON 구조를 내려줘야 프론트엔드에서 처리하기 편합니다.
예외 세분화 : 401,  403, 404로.  
GlobalExceptionHandler 구현해서 공통처리 


- secuity
로그인정보 사용하는곳은
@AuthenticationPrincipal CustomUserAccount userAccount  통일 




  
AI는 기존  만든 코드를 참고하기...

 

